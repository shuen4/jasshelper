unit ZincSymbols;
interface
type SymbolConstants = (
   SYMBOL_EOF                           =   0, (* (EOF) *)
   SYMBOL_ERROR                         =   1, (* (Error) *)
   SYMBOL_WHITESPACE                    =   2, (* (Whitespace) *)
   SYMBOL_COMMENTEND                    =   3, (* (Comment End) *)
   SYMBOL_COMMENTLINE                   =   4, (* (Comment Line) *)
   SYMBOL_COMMENTSTART                  =   5, (* (Comment Start) *)
   SYMBOL_MINUS                         =   6, (* - *)
   SYMBOL_EXCLAM                        =   7, (* ! *)
   SYMBOL_EXCLAMEQ                      =   8, (* != *)
   SYMBOL_AMPAMP                        =   9, (* && *)
   SYMBOL_LPARAN                        =  10, (* ( *)
   SYMBOL_RPARAN                        =  11, (* ) *)
   SYMBOL_TIMES                         =  12, (* * *)
   SYMBOL_TIMESEQ                       =  13, (* *= *)
   SYMBOL_COMMA                         =  14, (* , *)
   SYMBOL_DOT                           =  15, (* . *)
   SYMBOL_DIV                           =  16, (* / *)
   SYMBOL_DIVEQ                         =  17, (* /= *)
   SYMBOL_COLON                         =  18, (* : *)
   SYMBOL_SEMI                          =  19, (* ; *)
   SYMBOL_LBRACKET                      =  20, (* [ *)
   SYMBOL_RBRACKET                      =  21, (* ] *)
   SYMBOL_LBRACE                        =  22, (* { *)
   SYMBOL_PIPEPIPE                      =  23, (* || *)
   SYMBOL_RBRACE                        =  24, (* } *)
   SYMBOL_PLUS                          =  25, (* + *)
   SYMBOL_PLUSEQ                        =  26, (* += *)
   SYMBOL_LT                            =  27, (* < *)
   SYMBOL_LTEQ                          =  28, (* <= *)
   SYMBOL_EQ                            =  29, (* = *)
   SYMBOL_MINUSEQ                       =  30, (* -= *)
   SYMBOL_EQEQ                          =  31, (* == *)
   SYMBOL_GT                            =  32, (* > *)
   SYMBOL_MINUSGT                       =  33, (* -> *)
   SYMBOL_GTEQ                          =  34, (* >= *)
   SYMBOL_BREAK                         =  35, (* break *)
   SYMBOL_CHARLITERAL                   =  36, (* CharLiteral *)
   SYMBOL_CONSTANT                      =  37, (* constant *)
   SYMBOL_DEBUG                         =  38, (* debug *)
   SYMBOL_DECIMAL                       =  39, (* Decimal *)
   SYMBOL_DELEGATE                      =  40, (* delegate *)
   SYMBOL_DO                            =  41, (* do *)
   SYMBOL_ELSE                          =  42, (* else *)
   SYMBOL_EXTENDS                       =  43, (* extends *)
   SYMBOL_FOR                           =  44, (* for *)
   SYMBOL_FUNCTION                      =  45, (* function *)
   SYMBOL_HEX                           =  46, (* Hex *)
   SYMBOL_IDENTIFIER                    =  47, (* Identifier *)
   SYMBOL_IF                            =  48, (* if *)
   SYMBOL_INTERFACE                     =  49, (* interface *)
   SYMBOL_LIBRARY                       =  50, (* library *)
   SYMBOL_METHOD                        =  51, (* method *)
   SYMBOL_MODULE                        =  52, (* module *)
   SYMBOL_OCTAL                         =  53, (* Octal *)
   SYMBOL_OPERATOR                      =  54, (* operator *)
   SYMBOL_OPTIONAL                      =  55, (* optional *)
   SYMBOL_PREPROCESSORLINE              =  56, (* PreprocessorLine *)
   SYMBOL_PRIVATE                       =  57, (* private *)
   SYMBOL_PUBLIC                        =  58, (* public *)
   SYMBOL_REALNUMBER                    =  59, (* RealNumber *)
   SYMBOL_REQUIRES                      =  60, (* requires *)
   SYMBOL_RETURN                        =  61, (* return *)
   SYMBOL_STATIC                        =  62, (* static *)
   SYMBOL_STRINGLITERAL                 =  63, (* StringLiteral *)
   SYMBOL_STRUCT                        =  64, (* struct *)
   SYMBOL_TYPE                          =  65, (* type *)
   SYMBOL_WHILE                         =  66, (* while *)
   SYMBOL_ADDITION                      =  67, (* <Addition> *)
   SYMBOL_ADDITIONOPERATOR              =  68, (* <AdditionOperator> *)
   SYMBOL_ANONYMOUSFUNCTION             =  69, (* <AnonymousFunction> *)
   SYMBOL_ANONYMOUSTAG                  =  70, (* <AnonymousTag> *)
   SYMBOL_ARGUMENTDEFAULT               =  71, (* <ArgumentDefault> *)
   SYMBOL_ARRAYGET                      =  72, (* <ArrayGet> *)
   SYMBOL_ARRAYNAME                     =  73, (* <ArrayName> *)
   SYMBOL_ARRAYNAMESIZE                 =  74, (* <ArrayNameSize> *)
   SYMBOL_ARRAYNAMESIZESIZE             =  75, (* <ArrayNameSizeSize> *)
   SYMBOL_ASSIGNABLE                    =  76, (* <Assignable> *)
   SYMBOL_ASSIGNMENT                    =  77, (* <Assignment> *)
   SYMBOL_ASSIGNMENTS                   =  78, (* <Assignments> *)
   SYMBOL_BREAKSTATEMENT                =  79, (* <BreakStatement> *)
   SYMBOL_CALLARGUMENT                  =  80, (* <CallArgument> *)
   SYMBOL_CALLARGUMENTLIST              =  81, (* <CallArgumentList> *)
   SYMBOL_CALLARGUMENTS                 =  82, (* <CallArguments> *)
   SYMBOL_CODEBLOCK                     =  83, (* <CodeBlock> *)
   SYMBOL_CODEVALUE                     =  84, (* <CodeValue> *)
   SYMBOL_COLONARRAYGET                 =  85, (* <ColonArrayGet> *)
   SYMBOL_COMPARISSON                   =  86, (* <Comparisson> *)
   SYMBOL_COMPARISSONOPERATOR           =  87, (* <ComparissonOperator> *)
   SYMBOL_CONSTANT2                     =  88, (* <Constant> *)
   SYMBOL_DEBUG2                        =  89, (* <Debug> *)
   SYMBOL_DELEGATE2                     =  90, (* <Delegate> *)
   SYMBOL_DOWHILE                       =  91, (* <DoWhile> *)
   SYMBOL_DYNAMICARRAY                  =  92, (* <DynamicArray> *)
   SYMBOL_DYNAMICARRAYSTORAGELIMIT      =  93, (* <DynamicArrayStorageLimit> *)
   SYMBOL_EXITWHEN                      =  94, (* <Exitwhen> *)
   SYMBOL_EXPRESSION                    =  95, (* <Expression> *)
   SYMBOL_EXPRESSION2                   =  96, (* <Expression2> *)
   SYMBOL_EXPRESSION3                   =  97, (* <Expression3> *)
   SYMBOL_EXPRESSION4                   =  98, (* <Expression4> *)
   SYMBOL_EXPRESSION5                   =  99, (* <Expression5> *)
   SYMBOL_EXPRESSION6                   = 100, (* <Expression6> *)
   SYMBOL_EXPRESSION7                   = 101, (* <Expression7> *)
   SYMBOL_EXPRESSION8                   = 102, (* <Expression8> *)
   SYMBOL_EXTENDS2                      = 103, (* <Extends> *)
   SYMBOL_FOR2                          = 104, (* <For> *)
   SYMBOL_FORWHILE                      = 105, (* <ForWhile> *)
   SYMBOL_FUNCTION2                     = 106, (* <Function> *)
   SYMBOL_FUNCTIONARGUMENT              = 107, (* <FunctionArgument> *)
   SYMBOL_FUNCTIONARGUMENTLIST          = 108, (* <FunctionArgumentList> *)
   SYMBOL_FUNCTIONCALL                  = 109, (* <FunctionCall> *)
   SYMBOL_FUNCTIONCALLSTATEMENT         = 110, (* <FunctionCallStatement> *)
   SYMBOL_FUNCTIONINTERFACE             = 111, (* <FunctionInterface> *)
   SYMBOL_FUNCTIONINTERFACEARGUMENT     = 112, (* <FunctionInterfaceArgument> *)
   SYMBOL_FUNCTIONINTERFACEARGUMENTLIST = 113, (* <FunctionInterfaceArgumentList> *)
   SYMBOL_GLOBALVARIABLEDECLARATION     = 114, (* <GlobalVariableDeclaration> *)
   SYMBOL_IF2                           = 115, (* <If> *)
   SYMBOL_IFELSE                        = 116, (* <IfElse> *)
   SYMBOL_INTEGERLITERAL                = 117, (* <IntegerLiteral> *)
   SYMBOL_INTERFACE2                    = 118, (* <Interface> *)
   SYMBOL_INTERFACEBODY                 = 119, (* <InterfaceBody> *)
   SYMBOL_INTERFACEDEFAULTS             = 120, (* <InterfaceDefaults> *)
   SYMBOL_INTERFACEMEMBER               = 121, (* <InterfaceMember> *)
   SYMBOL_INTERFACEMETHOD               = 122, (* <InterfaceMethod> *)
   SYMBOL_INTERFACEPPBLOCK              = 123, (* <InterfacePPBlock> *)
   SYMBOL_LIBRARY2                      = 124, (* <Library> *)
   SYMBOL_LIBRARYMEMBER                 = 125, (* <LibraryMember> *)
   SYMBOL_LIBRARYMEMBERS                = 126, (* <LibraryMembers> *)
   SYMBOL_LIBRARYPPBLOCK                = 127, (* <LibraryPPBlock> *)
   SYMBOL_LIBRARYREQUIREMENTS           = 128, (* <LibraryRequirements> *)
   SYMBOL_LITERAL                       = 129, (* <Literal> *)
   SYMBOL_LOCALVARIABLE                 = 130, (* <LocalVariable> *)
   SYMBOL_LOGICALBINARY                 = 131, (* <LogicalBinary> *)
   SYMBOL_LOGICALBINARYOPERATOR         = 132, (* <LogicalBinaryOperator> *)
   SYMBOL_MEMBERGET                     = 133, (* <MemberGet> *)
   SYMBOL_METHODCALL                    = 134, (* <MethodCall> *)
   SYMBOL_METHODCALLSTATEMENT           = 135, (* <MethodCallStatement> *)
   SYMBOL_METHODNAME                    = 136, (* <MethodName> *)
   SYMBOL_MODULE2                       = 137, (* <Module> *)
   SYMBOL_NOT                           = 138, (* <Not> *)
   SYMBOL_OPERATOR2                     = 139, (* <Operator> *)
   SYMBOL_OPTIONALMODULE                = 140, (* <OptionalModule> *)
   SYMBOL_PARENTHESIS                   = 141, (* <Parenthesis> *)
   SYMBOL_PREPROCESSOR                  = 142, (* <Preprocessor> *)
   SYMBOL_PRIVATEPUBLIC                 = 143, (* <PrivatePublic> *)
   SYMBOL_PRODUCT                       = 144, (* <Product> *)
   SYMBOL_PRODUCTOPERATOR               = 145, (* <ProductOperator> *)
   SYMBOL_REALLITERAL                   = 146, (* <RealLiteral> *)
   SYMBOL_RELATION                      = 147, (* <Relation> *)
   SYMBOL_RELATIONOPERATOR              = 148, (* <RelationOperator> *)
   SYMBOL_REQUIREMENT                   = 149, (* <Requirement> *)
   SYMBOL_REQUIREMENTLIST               = 150, (* <RequirementList> *)
   SYMBOL_REQUIREMENTOPTIONAL           = 151, (* <RequirementOptional> *)
   SYMBOL_RETURN2                       = 152, (* <Return> *)
   SYMBOL_RETURNTYPE                    = 153, (* <ReturnType> *)
   SYMBOL_SIGN                          = 154, (* <Sign> *)
   SYMBOL_SIGNOPERATOR                  = 155, (* <SignOperator> *)
   SYMBOL_SINGLESTATEMENT               = 156, (* <SingleStatement> *)
   SYMBOL_SINGLEVARIABLE                = 157, (* <SingleVariable> *)
   SYMBOL_STATEMENT                     = 158, (* <Statement> *)
   SYMBOL_STATEMENTNOBREAK              = 159, (* <StatementNoBreak> *)
   SYMBOL_STATEMENTNOBREAKORBLOCK       = 160, (* <StatementNoBreakOrBlock> *)
   SYMBOL_STATEMENTORBLOCK              = 161, (* <StatementOrBlock> *)
   SYMBOL_STATEMENTS                    = 162, (* <Statements> *)
   SYMBOL_STATIC2                       = 163, (* <Static> *)
   SYMBOL_STATICIF                      = 164, (* <StaticIf> *)
   SYMBOL_STATICIFEXPRESSION            = 165, (* <StaticIfExpression> *)
   SYMBOL_STATICIFREQUIREMENT           = 166, (* <StaticIfRequirement> *)
   SYMBOL_STATICIFREQUIREMENTNOT        = 167, (* <StaticIfRequirementNot> *)
   SYMBOL_STORAGELIMIT                  = 168, (* <StorageLimit> *)
   SYMBOL_STRUCT2                       = 169, (* <Struct> *)
   SYMBOL_STRUCTARRAY                   = 170, (* <StructArray> *)
   SYMBOL_STRUCTBODY                    = 171, (* <StructBody> *)
   SYMBOL_STRUCTIMPLEMENT               = 172, (* <StructImplement> *)
   SYMBOL_STRUCTMEMBER                  = 173, (* <StructMember> *)
   SYMBOL_STRUCTMETHOD                  = 174, (* <StructMethod> *)
   SYMBOL_STRUCTPPBLOCK                 = 175, (* <StructPPBlock> *)
   SYMBOL_STRUCTVARIABLEDECLARATION     = 176, (* <StructVariableDeclaration> *)
   SYMBOL_TYPE2                         = 177, (* <Type> *)
   SYMBOL_TYPEDEF                       = 178, (* <TypeDef> *)
   SYMBOL_TYPEEXTENDS                   = 179, (* <TypeExtends> *)
   SYMBOL_VARIABLE                      = 180, (* <Variable> *)
   SYMBOL_VARIABLELIST                  = 181, (* <VariableList> *)
   SYMBOL_VARIABLENAME                  = 182, (* <VariableName> *)
   SYMBOL_VARIABLENAMEASSIGNED          = 183, (* <VariableNameAssigned> *)
   SYMBOL_WHILE2                        = 184, (* <While> *)
   SYMBOL_ZINC                          = 185  (* <Zinc> *)
);

type RuleConstants = (
   RULE_INTEGERLITERAL_DECIMAL                                           =   0, (* <IntegerLiteral> ::= Decimal *)
   RULE_INTEGERLITERAL_OCTAL                                             =   1, (* <IntegerLiteral> ::= Octal *)
   RULE_INTEGERLITERAL_HEX                                               =   2, (* <IntegerLiteral> ::= Hex *)
   RULE_INTEGERLITERAL_CHARLITERAL                                       =   3, (* <IntegerLiteral> ::= CharLiteral *)
   RULE_REALLITERAL_REALNUMBER                                           =   4, (* <RealLiteral> ::= RealNumber *)
   RULE_LITERAL_STRINGLITERAL                                            =   5, (* <Literal> ::= StringLiteral *)
   RULE_LITERAL                                                          =   6, (* <Literal> ::= <IntegerLiteral> *)
   RULE_LITERAL2                                                         =   7, (* <Literal> ::= <RealLiteral> *)
   RULE_TYPE_IDENTIFIER                                                  =   8, (* <Type> ::= Identifier *)
   RULE_REQUIREMENTOPTIONAL_OPTIONAL                                     =   9, (* <RequirementOptional> ::= optional *)
   RULE_REQUIREMENTOPTIONAL                                              =  10, (* <RequirementOptional> ::=  *)
   RULE_REQUIREMENT_IDENTIFIER                                           =  11, (* <Requirement> ::= <RequirementOptional> Identifier *)
   RULE_REQUIREMENT_TIMES                                                =  12, (* <Requirement> ::= * *)
   RULE_REQUIREMENTLIST_COMMA                                            =  13, (* <RequirementList> ::= <Requirement> , <RequirementList> *)
   RULE_REQUIREMENTLIST                                                  =  14, (* <RequirementList> ::= <Requirement> *)
   RULE_LIBRARYREQUIREMENTS_REQUIRES                                     =  15, (* <LibraryRequirements> ::= requires <RequirementList> *)
   RULE_LIBRARYREQUIREMENTS                                              =  16, (* <LibraryRequirements> ::=  *)
   RULE_VARIABLENAME_IDENTIFIER                                          =  17, (* <VariableName> ::= Identifier *)
   RULE_VARIABLENAMEASSIGNED_IDENTIFIER_EQ                               =  18, (* <VariableNameAssigned> ::= Identifier = <Expression> *)
   RULE_ARRAYNAME_IDENTIFIER_LBRACKET_RBRACKET                           =  19, (* <ArrayName> ::= Identifier [ ] *)
   RULE_ARRAYNAMESIZE_IDENTIFIER_LBRACKET_RBRACKET                       =  20, (* <ArrayNameSize> ::= Identifier [ <Expression> ] *)
   RULE_ARRAYNAMESIZESIZE_IDENTIFIER_LBRACKET_RBRACKET_LBRACKET_RBRACKET =  21, (* <ArrayNameSizeSize> ::= Identifier [ <Expression> ] [ <Expression> ] *)
   RULE_SINGLEVARIABLE                                                   =  22, (* <SingleVariable> ::= <VariableName> *)
   RULE_SINGLEVARIABLE2                                                  =  23, (* <SingleVariable> ::= <VariableNameAssigned> *)
   RULE_SINGLEVARIABLE3                                                  =  24, (* <SingleVariable> ::= <ArrayName> *)
   RULE_SINGLEVARIABLE4                                                  =  25, (* <SingleVariable> ::= <ArrayNameSize> *)
   RULE_SINGLEVARIABLE5                                                  =  26, (* <SingleVariable> ::= <ArrayNameSizeSize> *)
   RULE_VARIABLELIST_COMMA                                               =  27, (* <VariableList> ::= <SingleVariable> , <VariableList> *)
   RULE_VARIABLELIST                                                     =  28, (* <VariableList> ::= <SingleVariable> *)
   RULE_CONSTANT_CONSTANT                                                =  29, (* <Constant> ::= constant *)
   RULE_CONSTANT                                                         =  30, (* <Constant> ::=  *)
   RULE_GLOBALVARIABLEDECLARATION_SEMI                                   =  31, (* <GlobalVariableDeclaration> ::= <PrivatePublic> <Constant> <Type> <VariableList> ; *)
   RULE_VARIABLE_IDENTIFIER                                              =  32, (* <Variable> ::= Identifier *)
   RULE_CODEVALUE_FUNCTION_IDENTIFIER                                    =  33, (* <CodeValue> ::= function Identifier *)
   RULE_CODEVALUE_STATIC_METHOD_IDENTIFIER_DOT_IDENTIFIER                =  34, (* <CodeValue> ::= static method Identifier . Identifier *)
   RULE_MEMBERGET_DOT_IDENTIFIER                                         =  35, (* <MemberGet> ::= <Expression8> . Identifier *)
   RULE_ARRAYGET_LBRACKET_RBRACKET                                       =  36, (* <ArrayGet> ::= <Expression8> [ <Expression> ] *)
   RULE_COLONARRAYGET_COLON_IDENTIFIER                                   =  37, (* <ColonArrayGet> ::= <Expression8> : Identifier *)
   RULE_METHODCALL_DOT_IDENTIFIER_LPARAN_RPARAN                          =  38, (* <MethodCall> ::= <Expression8> . Identifier ( <CallArgumentList> ) *)
   RULE_EXPRESSION8                                                      =  39, (* <Expression8> ::= <ArrayGet> *)
   RULE_EXPRESSION82                                                     =  40, (* <Expression8> ::= <ColonArrayGet> *)
   RULE_EXPRESSION83                                                     =  41, (* <Expression8> ::= <MemberGet> *)
   RULE_EXPRESSION84                                                     =  42, (* <Expression8> ::= <FunctionCall> *)
   RULE_EXPRESSION85                                                     =  43, (* <Expression8> ::= <MethodCall> *)
   RULE_EXPRESSION86                                                     =  44, (* <Expression8> ::= <Variable> *)
   RULE_EXPRESSION87                                                     =  45, (* <Expression8> ::= <Literal> *)
   RULE_EXPRESSION88                                                     =  46, (* <Expression8> ::= <CodeValue> *)
   RULE_EXPRESSION89                                                     =  47, (* <Expression8> ::= <AnonymousFunction> *)
   RULE_EXPRESSION810                                                    =  48, (* <Expression8> ::= <Parenthesis> *)
   RULE_NOT_EXCLAM                                                       =  49, (* <Not> ::= ! <Expression7> *)
   RULE_EXPRESSION7                                                      =  50, (* <Expression7> ::= <Not> *)
   RULE_EXPRESSION72                                                     =  51, (* <Expression7> ::= <Expression8> *)
   RULE_SIGNOPERATOR_PLUS                                                =  52, (* <SignOperator> ::= + *)
   RULE_SIGNOPERATOR_MINUS                                               =  53, (* <SignOperator> ::= - *)
   RULE_SIGN                                                             =  54, (* <Sign> ::= <SignOperator> <Expression6> *)
   RULE_EXPRESSION6                                                      =  55, (* <Expression6> ::= <Sign> *)
   RULE_EXPRESSION62                                                     =  56, (* <Expression6> ::= <Expression7> *)
   RULE_PRODUCTOPERATOR_TIMES                                            =  57, (* <ProductOperator> ::= * *)
   RULE_PRODUCTOPERATOR_DIV                                              =  58, (* <ProductOperator> ::= / *)
   RULE_PRODUCT                                                          =  59, (* <Product> ::= <Expression5> <ProductOperator> <Expression6> *)
   RULE_EXPRESSION5                                                      =  60, (* <Expression5> ::= <Product> *)
   RULE_EXPRESSION52                                                     =  61, (* <Expression5> ::= <Expression6> *)
   RULE_ADDITIONOPERATOR_PLUS                                            =  62, (* <AdditionOperator> ::= + *)
   RULE_ADDITIONOPERATOR_MINUS                                           =  63, (* <AdditionOperator> ::= - *)
   RULE_ADDITION                                                         =  64, (* <Addition> ::= <Expression4> <AdditionOperator> <Expression5> *)
   RULE_EXPRESSION4                                                      =  65, (* <Expression4> ::= <Addition> *)
   RULE_EXPRESSION42                                                     =  66, (* <Expression4> ::= <Expression5> *)
   RULE_RELATIONOPERATOR_GT                                              =  67, (* <RelationOperator> ::= > *)
   RULE_RELATIONOPERATOR_GTEQ                                            =  68, (* <RelationOperator> ::= >= *)
   RULE_RELATIONOPERATOR_LT                                              =  69, (* <RelationOperator> ::= < *)
   RULE_RELATIONOPERATOR_LTEQ                                            =  70, (* <RelationOperator> ::= <= *)
   RULE_RELATION                                                         =  71, (* <Relation> ::= <Expression4> <RelationOperator> <Expression4> *)
   RULE_EXPRESSION3                                                      =  72, (* <Expression3> ::= <Relation> *)
   RULE_EXPRESSION32                                                     =  73, (* <Expression3> ::= <Expression4> *)
   RULE_COMPARISSONOPERATOR_EQEQ                                         =  74, (* <ComparissonOperator> ::= == *)
   RULE_COMPARISSONOPERATOR_EXCLAMEQ                                     =  75, (* <ComparissonOperator> ::= != *)
   RULE_COMPARISSON                                                      =  76, (* <Comparisson> ::= <Expression3> <ComparissonOperator> <Expression3> *)
   RULE_EXPRESSION2                                                      =  77, (* <Expression2> ::= <Comparisson> *)
   RULE_EXPRESSION22                                                     =  78, (* <Expression2> ::= <Expression3> *)
   RULE_PARENTHESIS_LPARAN_RPARAN                                        =  79, (* <Parenthesis> ::= ( <Expression> ) *)
   RULE_LOGICALBINARYOPERATOR_AMPAMP                                     =  80, (* <LogicalBinaryOperator> ::= && *)
   RULE_LOGICALBINARYOPERATOR_PIPEPIPE                                   =  81, (* <LogicalBinaryOperator> ::= || *)
   RULE_LOGICALBINARY                                                    =  82, (* <LogicalBinary> ::= <Expression2> <LogicalBinaryOperator> <Expression> *)
   RULE_EXPRESSION                                                       =  83, (* <Expression> ::= <LogicalBinary> *)
   RULE_EXPRESSION9                                                      =  84, (* <Expression> ::= <Expression2> *)
   RULE_PRIVATEPUBLIC_PRIVATE                                            =  85, (* <PrivatePublic> ::= private *)
   RULE_PRIVATEPUBLIC_PUBLIC                                             =  86, (* <PrivatePublic> ::= public *)
   RULE_PRIVATEPUBLIC                                                    =  87, (* <PrivatePublic> ::=  *)
   RULE_ARGUMENTDEFAULT_EQ                                               =  88, (* <ArgumentDefault> ::= = <Expression> *)
   RULE_ARGUMENTDEFAULT                                                  =  89, (* <ArgumentDefault> ::=  *)
   RULE_FUNCTIONARGUMENT_IDENTIFIER                                      =  90, (* <FunctionArgument> ::= <Type> Identifier <ArgumentDefault> *)
   RULE_FUNCTIONARGUMENTLIST                                             =  91, (* <FunctionArgumentList> ::= <FunctionArgument> *)
   RULE_FUNCTIONARGUMENTLIST_COMMA                                       =  92, (* <FunctionArgumentList> ::= <FunctionArgument> , <FunctionArgumentList> *)
   RULE_FUNCTIONARGUMENTLIST2                                            =  93, (* <FunctionArgumentList> ::=  *)
   RULE_FUNCTIONINTERFACEARGUMENT                                        =  94, (* <FunctionInterfaceArgument> ::= <Type> *)
   RULE_FUNCTIONINTERFACEARGUMENTLIST                                    =  95, (* <FunctionInterfaceArgumentList> ::= <FunctionInterfaceArgument> *)
   RULE_FUNCTIONINTERFACEARGUMENTLIST_COMMA                              =  96, (* <FunctionInterfaceArgumentList> ::= <FunctionInterfaceArgument> , <FunctionInterfaceArgumentList> *)
   RULE_FUNCTIONINTERFACEARGUMENTLIST2                                   =  97, (* <FunctionInterfaceArgumentList> ::=  *)
   RULE_RETURNTYPE_MINUSGT                                               =  98, (* <ReturnType> ::= -> <Type> *)
   RULE_RETURNTYPE                                                       =  99, (* <ReturnType> ::=  *)
   RULE_ASSIGNABLE                                                       = 100, (* <Assignable> ::= <Variable> *)
   RULE_ASSIGNABLE2                                                      = 101, (* <Assignable> ::= <ArrayGet> *)
   RULE_ASSIGNABLE3                                                      = 102, (* <Assignable> ::= <ColonArrayGet> *)
   RULE_ASSIGNABLE4                                                      = 103, (* <Assignable> ::= <MemberGet> *)
   RULE_ASSIGNMENT_EQ                                                    = 104, (* <Assignment> ::= <Assignable> = <Expression> *)
   RULE_ASSIGNMENT_PLUSEQ                                                = 105, (* <Assignment> ::= <Assignable> += <Expression> *)
   RULE_ASSIGNMENT_MINUSEQ                                               = 106, (* <Assignment> ::= <Assignable> -= <Expression> *)
   RULE_ASSIGNMENT_DIVEQ                                                 = 107, (* <Assignment> ::= <Assignable> /= <Expression> *)
   RULE_ASSIGNMENT_TIMESEQ                                               = 108, (* <Assignment> ::= <Assignable> *= <Expression> *)
   RULE_ASSIGNMENTS_COMMA                                                = 109, (* <Assignments> ::= <Assignments> , <Assignment> *)
   RULE_ASSIGNMENTS                                                      = 110, (* <Assignments> ::= <Assignment> *)
   RULE_RETURN_RETURN                                                    = 111, (* <Return> ::= return <Expression> *)
   RULE_RETURN_RETURN2                                                   = 112, (* <Return> ::= return *)
   RULE_IF_IF                                                            = 113, (* <If> ::= if <Parenthesis> <StatementNoBreakOrBlock> *)
   RULE_IFELSE_IF_ELSE                                                   = 114, (* <IfElse> ::= if <Parenthesis> <StatementNoBreakOrBlock> else <StatementNoBreakOrBlock> *)
   RULE_EXITWHEN_IF_BREAK_SEMI                                           = 115, (* <Exitwhen> ::= if <Parenthesis> break ; *)
   RULE_WHILE_WHILE                                                      = 116, (* <While> ::= while <Parenthesis> <StatementOrBlock> *)
   RULE_DOWHILE_DO_WHILE_SEMI                                            = 117, (* <DoWhile> ::= do <StatementOrBlock> while <Parenthesis> ; *)
   RULE_DEBUG_DEBUG                                                      = 118, (* <Debug> ::= debug <StatementOrBlock> *)
   RULE_FOR_FOR_LPARAN_RPARAN                                            = 119, (* <For> ::= for ( <Expression4> <RelationOperator> <Variable> <RelationOperator> <Expression4> ) <StatementOrBlock> *)
   RULE_FORWHILE_FOR_LPARAN_SEMI_SEMI_RPARAN                             = 120, (* <ForWhile> ::= for ( <Assignments> ; <Expression> ; <Assignments> ) <StatementOrBlock> *)
   RULE_STATICIFREQUIREMENTNOT_EXCLAM                                    = 121, (* <StaticIfRequirementNot> ::= ! *)
   RULE_STATICIFREQUIREMENTNOT                                           = 122, (* <StaticIfRequirementNot> ::=  *)
   RULE_STATICIFREQUIREMENT_IDENTIFIER                                   = 123, (* <StaticIfRequirement> ::= <StaticIfRequirementNot> Identifier *)
   RULE_STATICIFREQUIREMENT_IDENTIFIER_DOT_IDENTIFIER                    = 124, (* <StaticIfRequirement> ::= <StaticIfRequirementNot> Identifier . Identifier *)
   RULE_STATICIFREQUIREMENT_IDENTIFIER_DOT_IDENTIFIER_DOT_IDENTIFIER     = 125, (* <StaticIfRequirement> ::= <StaticIfRequirementNot> Identifier . Identifier . Identifier *)
   RULE_STATICIFEXPRESSION                                               = 126, (* <StaticIfExpression> ::= <StaticIfRequirement> *)
   RULE_STATICIFEXPRESSION_AMPAMP                                        = 127, (* <StaticIfExpression> ::= <StaticIfExpression> && <StaticIfRequirement> *)
   RULE_STATICIF_STATIC_IF_LPARAN_RPARAN                                 = 128, (* <StaticIf> ::= static if ( <StaticIfExpression> ) <StatementOrBlock> *)
   RULE_STATICIF_STATIC_IF_LPARAN_RPARAN_ELSE                            = 129, (* <StaticIf> ::= static if ( <StaticIfExpression> ) <StatementOrBlock> else <StatementOrBlock> *)
   RULE_CALLARGUMENT                                                     = 130, (* <CallArgument> ::= <Expression> *)
   RULE_CALLARGUMENTS                                                    = 131, (* <CallArguments> ::= <CallArgument> *)
   RULE_CALLARGUMENTS_COMMA                                              = 132, (* <CallArguments> ::= <CallArgument> , <CallArguments> *)
   RULE_CALLARGUMENTLIST                                                 = 133, (* <CallArgumentList> ::= <CallArguments> *)
   RULE_CALLARGUMENTLIST2                                                = 134, (* <CallArgumentList> ::=  *)
   RULE_FUNCTIONCALL_IDENTIFIER_LPARAN_RPARAN                            = 135, (* <FunctionCall> ::= Identifier ( <CallArgumentList> ) *)
   RULE_METHODCALLSTATEMENT_SEMI                                         = 136, (* <MethodCallStatement> ::= <MethodCall> ; *)
   RULE_FUNCTIONCALLSTATEMENT_SEMI                                       = 137, (* <FunctionCallStatement> ::= <FunctionCall> ; *)
   RULE_BREAKSTATEMENT_BREAK_SEMI                                        = 138, (* <BreakStatement> ::= break ; *)
   RULE_SINGLESTATEMENT                                                  = 139, (* <SingleStatement> ::= <Return> *)
   RULE_SINGLESTATEMENT2                                                 = 140, (* <SingleStatement> ::= <Assignments> *)
   RULE_LOCALVARIABLE_SEMI                                               = 141, (* <LocalVariable> ::= <Type> <VariableList> ; *)
   RULE_STATEMENTNOBREAK                                                 = 142, (* <StatementNoBreak> ::= <Debug> *)
   RULE_STATEMENTNOBREAK2                                                = 143, (* <StatementNoBreak> ::= <While> *)
   RULE_STATEMENTNOBREAK3                                                = 144, (* <StatementNoBreak> ::= <For> *)
   RULE_STATEMENTNOBREAK4                                                = 145, (* <StatementNoBreak> ::= <If> *)
   RULE_STATEMENTNOBREAK5                                                = 146, (* <StatementNoBreak> ::= <StaticIf> *)
   RULE_STATEMENTNOBREAK6                                                = 147, (* <StatementNoBreak> ::= <IfElse> *)
   RULE_STATEMENTNOBREAK7                                                = 148, (* <StatementNoBreak> ::= <Exitwhen> *)
   RULE_STATEMENTNOBREAK_SEMI                                            = 149, (* <StatementNoBreak> ::= <SingleStatement> ; *)
   RULE_STATEMENTNOBREAK8                                                = 150, (* <StatementNoBreak> ::= <FunctionCallStatement> *)
   RULE_STATEMENTNOBREAK9                                                = 151, (* <StatementNoBreak> ::= <MethodCallStatement> *)
   RULE_STATEMENTNOBREAK10                                               = 152, (* <StatementNoBreak> ::= <LocalVariable> *)
   RULE_STATEMENTNOBREAK11                                               = 153, (* <StatementNoBreak> ::= <ForWhile> *)
   RULE_STATEMENTNOBREAK12                                               = 154, (* <StatementNoBreak> ::= <DoWhile> *)
   RULE_STATEMENT                                                        = 155, (* <Statement> ::= <StatementNoBreak> *)
   RULE_STATEMENT2                                                       = 156, (* <Statement> ::= <BreakStatement> *)
   RULE_STATEMENTS                                                       = 157, (* <Statements> ::= <Statement> <Statements> *)
   RULE_STATEMENTS2                                                      = 158, (* <Statements> ::=  *)
   RULE_CODEBLOCK_LBRACE_RBRACE                                          = 159, (* <CodeBlock> ::= { <Statements> } *)
   RULE_STATEMENTORBLOCK                                                 = 160, (* <StatementOrBlock> ::= <Statement> *)
   RULE_STATEMENTORBLOCK2                                                = 161, (* <StatementOrBlock> ::= <CodeBlock> *)
   RULE_STATEMENTNOBREAKORBLOCK                                          = 162, (* <StatementNoBreakOrBlock> ::= <StatementNoBreak> *)
   RULE_STATEMENTNOBREAKORBLOCK2                                         = 163, (* <StatementNoBreakOrBlock> ::= <CodeBlock> *)
   RULE_FUNCTION_FUNCTION_IDENTIFIER_LPARAN_RPARAN                       = 164, (* <Function> ::= <PrivatePublic> function Identifier ( <FunctionArgumentList> ) <ReturnType> <CodeBlock> *)
   RULE_ANONYMOUSTAG_FUNCTION                                            = 165, (* <AnonymousTag> ::= function *)
   RULE_ANONYMOUSTAG_STATIC_METHOD                                       = 166, (* <AnonymousTag> ::= static method *)
   RULE_ANONYMOUSTAG_METHOD                                              = 167, (* <AnonymousTag> ::= method *)
   RULE_ANONYMOUSFUNCTION_LPARAN_RPARAN                                  = 168, (* <AnonymousFunction> ::= <AnonymousTag> ( <FunctionArgumentList> ) <ReturnType> <CodeBlock> *)
   RULE_STATIC_STATIC                                                    = 169, (* <Static> ::= static *)
   RULE_STATIC                                                           = 170, (* <Static> ::=  *)
   RULE_DELEGATE_DELEGATE                                                = 171, (* <Delegate> ::= delegate *)
   RULE_DELEGATE                                                         = 172, (* <Delegate> ::=  *)
   RULE_STRUCTVARIABLEDECLARATION_SEMI                                   = 173, (* <StructVariableDeclaration> ::= <PrivatePublic> <Static> <Delegate> <Constant> <Type> <VariableList> ; *)
   RULE_OPERATOR_OPERATOR_LT                                             = 174, (* <Operator> ::= operator < *)
   RULE_OPERATOR_OPERATOR_LBRACKET_RBRACKET                              = 175, (* <Operator> ::= operator [ ] *)
   RULE_OPERATOR_OPERATOR_LBRACKET_RBRACKET_EQ                           = 176, (* <Operator> ::= operator [ ] = *)
   RULE_OPERATOR_OPERATOR_IDENTIFIER                                     = 177, (* <Operator> ::= operator Identifier *)
   RULE_OPERATOR_OPERATOR_IDENTIFIER_EQ                                  = 178, (* <Operator> ::= operator Identifier = *)
   RULE_OPERATOR_OPERATOR_EQEQ                                           = 179, (* <Operator> ::= operator == *)
   RULE_METHODNAME                                                       = 180, (* <MethodName> ::= <Operator> *)
   RULE_METHODNAME_IDENTIFIER                                            = 181, (* <MethodName> ::= Identifier *)
   RULE_STRUCTMETHOD_METHOD_LPARAN_RPARAN                                = 182, (* <StructMethod> ::= <PrivatePublic> <Static> method <MethodName> ( <FunctionArgumentList> ) <ReturnType> <CodeBlock> *)
   RULE_INTERFACEDEFAULTS_EQ                                             = 183, (* <InterfaceDefaults> ::= = <Expression> *)
   RULE_INTERFACEDEFAULTS                                                = 184, (* <InterfaceDefaults> ::=  *)
   RULE_INTERFACEMETHOD_METHOD_LPARAN_RPARAN_SEMI                        = 185, (* <InterfaceMethod> ::= <PrivatePublic> <Static> method <MethodName> ( <FunctionArgumentList> ) <ReturnType> <InterfaceDefaults> ; *)
   RULE_OPTIONALMODULE_OPTIONAL                                          = 186, (* <OptionalModule> ::= optional *)
   RULE_OPTIONALMODULE                                                   = 187, (* <OptionalModule> ::=  *)
   RULE_STRUCTIMPLEMENT_MODULE_IDENTIFIER_SEMI                           = 188, (* <StructImplement> ::= <OptionalModule> module Identifier ; *)
   RULE_STRUCTMEMBER                                                     = 189, (* <StructMember> ::= <StructVariableDeclaration> *)
   RULE_STRUCTMEMBER2                                                    = 190, (* <StructMember> ::= <StructMethod> *)
   RULE_STRUCTMEMBER3                                                    = 191, (* <StructMember> ::= <StructImplement> *)
   RULE_STRUCTMEMBER4                                                    = 192, (* <StructMember> ::= <StructPPBlock> *)
   RULE_INTERFACEMEMBER                                                  = 193, (* <InterfaceMember> ::= <StructVariableDeclaration> *)
   RULE_INTERFACEMEMBER2                                                 = 194, (* <InterfaceMember> ::= <InterfaceMethod> *)
   RULE_INTERFACEMEMBER3                                                 = 195, (* <InterfaceMember> ::= <InterfacePPBlock> *)
   RULE_STRUCTBODY                                                       = 196, (* <StructBody> ::= <StructMember> <StructBody> *)
   RULE_STRUCTBODY2                                                      = 197, (* <StructBody> ::=  *)
   RULE_INTERFACEBODY                                                    = 198, (* <InterfaceBody> ::= <InterfaceMember> <InterfaceBody> *)
   RULE_INTERFACEBODY2                                                   = 199, (* <InterfaceBody> ::=  *)
   RULE_EXTENDS_EXTENDS_IDENTIFIER                                       = 200, (* <Extends> ::= extends Identifier *)
   RULE_EXTENDS                                                          = 201, (* <Extends> ::=  *)
   RULE_STORAGELIMIT_LBRACKET_RBRACKET                                   = 202, (* <StorageLimit> ::= [ <Expression> ] *)
   RULE_STORAGELIMIT                                                     = 203, (* <StorageLimit> ::=  *)
   RULE_STRUCTARRAY_LBRACKET_RBRACKET                                    = 204, (* <StructArray> ::= [ ] *)
   RULE_STRUCTARRAY_LBRACKET_RBRACKET2                                   = 205, (* <StructArray> ::= [ <Expression> ] *)
   RULE_STRUCTARRAY                                                      = 206, (* <StructArray> ::=  *)
   RULE_STRUCT_STRUCT_IDENTIFIER_LBRACE_RBRACE                           = 207, (* <Struct> ::= <PrivatePublic> struct <StorageLimit> Identifier <StructArray> <Extends> { <StructBody> } *)
   RULE_MODULE_MODULE_IDENTIFIER_LBRACE_RBRACE                           = 208, (* <Module> ::= <PrivatePublic> module Identifier { <StructBody> } *)
   RULE_INTERFACE_INTERFACE_IDENTIFIER_LBRACE_RBRACE                     = 209, (* <Interface> ::= <PrivatePublic> interface <StorageLimit> Identifier { <InterfaceBody> } *)
   RULE_DYNAMICARRAYSTORAGELIMIT_COMMA                                   = 210, (* <DynamicArrayStorageLimit> ::= , <Expression> *)
   RULE_DYNAMICARRAYSTORAGELIMIT                                         = 211, (* <DynamicArrayStorageLimit> ::=  *)
   RULE_DYNAMICARRAY_LBRACKET_RBRACKET                                   = 212, (* <DynamicArray> ::= <Type> [ <Expression> <DynamicArrayStorageLimit> ] *)
   RULE_FUNCTIONINTERFACE_FUNCTION_LPARAN_RPARAN                         = 213, (* <FunctionInterface> ::= function ( <FunctionInterfaceArgumentList> ) <ReturnType> *)
   RULE_TYPEEXTENDS                                                      = 214, (* <TypeExtends> ::= <DynamicArray> *)
   RULE_TYPEEXTENDS2                                                     = 215, (* <TypeExtends> ::= <FunctionInterface> *)
   RULE_TYPEDEF_TYPE_IDENTIFIER_EXTENDS_SEMI                             = 216, (* <TypeDef> ::= <PrivatePublic> type Identifier extends <TypeExtends> ; *)
   RULE_PREPROCESSOR_PREPROCESSORLINE                                    = 217, (* <Preprocessor> ::= PreprocessorLine *)
   RULE_LIBRARYMEMBER                                                    = 218, (* <LibraryMember> ::= <GlobalVariableDeclaration> *)
   RULE_LIBRARYMEMBER2                                                   = 219, (* <LibraryMember> ::= <Function> *)
   RULE_LIBRARYMEMBER3                                                   = 220, (* <LibraryMember> ::= <Struct> *)
   RULE_LIBRARYMEMBER4                                                   = 221, (* <LibraryMember> ::= <Module> *)
   RULE_LIBRARYMEMBER5                                                   = 222, (* <LibraryMember> ::= <Interface> *)
   RULE_LIBRARYMEMBER6                                                   = 223, (* <LibraryMember> ::= <TypeDef> *)
   RULE_LIBRARYMEMBER7                                                   = 224, (* <LibraryMember> ::= <Preprocessor> *)
   RULE_LIBRARYMEMBER8                                                   = 225, (* <LibraryMember> ::= <LibraryPPBlock> *)
   RULE_LIBRARYMEMBERS                                                   = 226, (* <LibraryMembers> ::= <LibraryMember> <LibraryMembers> *)
   RULE_LIBRARYMEMBERS2                                                  = 227, (* <LibraryMembers> ::=  *)
   RULE_LIBRARY_LIBRARY_IDENTIFIER_LBRACE_RBRACE                         = 228, (* <Library> ::= library Identifier <LibraryRequirements> { <LibraryMembers> } *)
   RULE_ZINC                                                             = 229, (* <Zinc> ::= <Library> <Zinc> *)
   RULE_ZINC2                                                            = 230, (* <Zinc> ::= <Preprocessor> <Zinc> *)
   RULE_ZINC3                                                            = 231, (* <Zinc> ::=  *)
   RULE_LIBRARYPPBLOCK_LBRACE_RBRACE                                     = 232, (* <LibraryPPBlock> ::= <PrivatePublic> { <LibraryMembers> } *)
   RULE_STRUCTPPBLOCK_LBRACE_RBRACE                                      = 233, (* <StructPPBlock> ::= <PrivatePublic> { <StructBody> } *)
   RULE_INTERFACEPPBLOCK_LBRACE_RBRACE                                   = 234  (* <InterfacePPBlock> ::= <PrivatePublic> { <InterfaceBody> } *)
);
implementation
end.
